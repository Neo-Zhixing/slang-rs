/* automatically generated by rust-bindgen 0.59.2 */

pub const SLANG_VC: u32 = 14;
pub const SLANG_CLANG: u32 = 0;
pub const SLANG_SNC: u32 = 0;
pub const SLANG_GHS: u32 = 0;
pub const SLANG_GCC: u32 = 0;
pub const SLANG_WIN64: u32 = 1;
pub const SLANG_WINRT: u32 = 0;
pub const SLANG_XBOXONE: u32 = 0;
pub const SLANG_X360: u32 = 0;
pub const SLANG_WIN32: u32 = 0;
pub const SLANG_ANDROID: u32 = 0;
pub const SLANG_LINUX: u32 = 0;
pub const SLANG_IOS: u32 = 0;
pub const SLANG_OSX: u32 = 0;
pub const SLANG_PS3: u32 = 0;
pub const SLANG_PS4: u32 = 0;
pub const SLANG_PSP2: u32 = 0;
pub const SLANG_WIIU: u32 = 0;
pub const SLANG_HAS_EXCEPTIONS: u32 = 1;
pub const SLANG_HAS_MOVE_SEMANTICS: u32 = 1;
pub const SLANG_HAS_ENUM_CLASS: u32 = 1;
pub const SLANG_PROCESSOR_X86_64: u32 = 1;
pub const SLANG_PROCESSOR_ARM: u32 = 0;
pub const SLANG_PROCESSOR_ARM_64: u32 = 0;
pub const SLANG_PROCESSOR_X86: u32 = 0;
pub const SLANG_PROCESSOR_POWER_PC: u32 = 0;
pub const SLANG_PROCESSOR_POWER_PC_64: u32 = 0;
pub const SLANG_PROCESSOR_FAMILY_X86: u32 = 1;
pub const SLANG_PROCESSOR_FAMILY_ARM: u32 = 0;
pub const SLANG_PROCESSOR_FAMILY_POWER_PC: u32 = 0;
pub const SLANG_PTR_IS_64: u32 = 1;
pub const SLANG_PTR_IS_32: u32 = 0;
pub const SLANG_LITTLE_ENDIAN: u32 = 1;
pub const SLANG_UNALIGNED_ACCESS: u32 = 1;
pub const SLANG_BIG_ENDIAN: u32 = 0;
pub const SLANG_FACILITY_WIN_GENERAL: u32 = 0;
pub const SLANG_FACILITY_WIN_INTERFACE: u32 = 4;
pub const SLANG_FACILITY_WIN_API: u32 = 7;
pub const SLANG_FACILITY_BASE: u32 = 512;
pub const SLANG_FACILITY_CORE: u32 = 512;
pub const SLANG_FACILITY_INTERNAL: u32 = 513;
pub const SLANG_FACILITY_EXTERNAL_BASE: u32 = 528;
pub const SLANG_OK: u32 = 0;
pub const SLANG_API_VERSION: u32 = 0;
#[doc = "@mainpage Introduction"]
#[doc = ""]
#[doc = "API Reference: slang.h"]
#[doc = ""]
#[doc = "@file slang.h"]
pub type SlangUInt32 = u32;
pub type SlangInt32 = i32;
pub type SlangInt = i64;
pub type SlangUInt = u64;
pub type SlangSizeT = u64;
pub type SlangBool = bool;
#[doc = "@brief Severity of a diagnostic generated by the compiler."]
#[doc = "Values come from the enum below, with higher values representing more severe"]
#[doc = "conditions, and all values >= SLANG_SEVERITY_ERROR indicating compilation"]
#[doc = "failure."]
pub type SlangSeverity = ::std::os::raw::c_int;
#[doc = "< An informative message."]
pub const SLANG_SEVERITY_NOTE: ::std::os::raw::c_int = 0;
#[doc = "< A warning, which indicates a possible proble."]
pub const SLANG_SEVERITY_WARNING: ::std::os::raw::c_int = 1;
#[doc = "< An error, indicating that compilation failed."]
pub const SLANG_SEVERITY_ERROR: ::std::os::raw::c_int = 2;
#[doc = "< An unrecoverable error, which forced compilation to abort."]
pub const SLANG_SEVERITY_FATAL: ::std::os::raw::c_int = 3;
#[doc = "< An internal error, indicating a logic error in the compiler."]
pub const SLANG_SEVERITY_INTERNAL: ::std::os::raw::c_int = 4;
pub type _bindgen_ty_1 = ::std::os::raw::c_int;
pub type SlangBindableResourceType = ::std::os::raw::c_int;
pub const SLANG_NON_BINDABLE: ::std::os::raw::c_int = 0;
pub const SLANG_TEXTURE: ::std::os::raw::c_int = 1;
pub const SLANG_SAMPLER: ::std::os::raw::c_int = 2;
pub const SLANG_UNIFORM_BUFFER: ::std::os::raw::c_int = 3;
pub const SLANG_STORAGE_BUFFER: ::std::os::raw::c_int = 4;
pub type _bindgen_ty_2 = ::std::os::raw::c_int;
pub type SlangCompileTarget = ::std::os::raw::c_int;
pub const SLANG_TARGET_UNKNOWN: ::std::os::raw::c_int = 0;
pub const SLANG_TARGET_NONE: ::std::os::raw::c_int = 1;
pub const SLANG_GLSL: ::std::os::raw::c_int = 2;
pub const SLANG_GLSL_VULKAN: ::std::os::raw::c_int = 3;
pub const SLANG_GLSL_VULKAN_ONE_DESC: ::std::os::raw::c_int = 4;
pub const SLANG_HLSL: ::std::os::raw::c_int = 5;
pub const SLANG_SPIRV: ::std::os::raw::c_int = 6;
pub const SLANG_SPIRV_ASM: ::std::os::raw::c_int = 7;
pub const SLANG_DXBC: ::std::os::raw::c_int = 8;
pub const SLANG_DXBC_ASM: ::std::os::raw::c_int = 9;
pub const SLANG_DXIL: ::std::os::raw::c_int = 10;
pub const SLANG_DXIL_ASM: ::std::os::raw::c_int = 11;
#[doc = "< The C language"]
pub const SLANG_C_SOURCE: ::std::os::raw::c_int = 12;
#[doc = "< The C++ language"]
pub const SLANG_CPP_SOURCE: ::std::os::raw::c_int = 13;
#[doc = "< Executable (for hosting CPU/OS)"]
pub const SLANG_EXECUTABLE: ::std::os::raw::c_int = 14;
#[doc = "< A shared library/Dll (for hosting CPU/OS)"]
pub const SLANG_SHARED_LIBRARY: ::std::os::raw::c_int = 15;
#[doc = "< A CPU target that makes the compiled code available to be run immediately"]
pub const SLANG_HOST_CALLABLE: ::std::os::raw::c_int = 16;
#[doc = "< Cuda source"]
pub const SLANG_CUDA_SOURCE: ::std::os::raw::c_int = 17;
#[doc = "< PTX"]
pub const SLANG_PTX: ::std::os::raw::c_int = 18;
#[doc = "< Object code that can be used for later linking"]
pub const SLANG_OBJECT_CODE: ::std::os::raw::c_int = 19;
pub const SLANG_TARGET_COUNT_OF: ::std::os::raw::c_int = 20;
pub type _bindgen_ty_3 = ::std::os::raw::c_int;
pub type SlangContainerFormat = ::std::os::raw::c_int;
pub const SLANG_CONTAINER_FORMAT_NONE: ::std::os::raw::c_int = 0;
pub const SLANG_CONTAINER_FORMAT_SLANG_MODULE: ::std::os::raw::c_int = 1;
pub type _bindgen_ty_4 = ::std::os::raw::c_int;
pub type SlangPassThroughIntegral = ::std::os::raw::c_int;
pub const SlangPassThrough_SLANG_PASS_THROUGH_NONE: SlangPassThrough = 0;
pub const SlangPassThrough_SLANG_PASS_THROUGH_FXC: SlangPassThrough = 1;
pub const SlangPassThrough_SLANG_PASS_THROUGH_DXC: SlangPassThrough = 2;
pub const SlangPassThrough_SLANG_PASS_THROUGH_GLSLANG: SlangPassThrough = 3;
#[doc = "< Clang C/C++ compiler"]
pub const SlangPassThrough_SLANG_PASS_THROUGH_CLANG: SlangPassThrough = 4;
#[doc = "< Visual studio C/C++ compiler"]
pub const SlangPassThrough_SLANG_PASS_THROUGH_VISUAL_STUDIO: SlangPassThrough = 5;
#[doc = "< GCC C/C++ compiler"]
pub const SlangPassThrough_SLANG_PASS_THROUGH_GCC: SlangPassThrough = 6;
#[doc = "< Generic C or C++ compiler, which is decided by the source type"]
pub const SlangPassThrough_SLANG_PASS_THROUGH_GENERIC_C_CPP: SlangPassThrough = 7;
#[doc = "< NVRTC Cuda compiler"]
pub const SlangPassThrough_SLANG_PASS_THROUGH_NVRTC: SlangPassThrough = 8;
#[doc = "< LLVM 'compiler' - includes LLVM and Clang"]
pub const SlangPassThrough_SLANG_PASS_THROUGH_LLVM: SlangPassThrough = 9;
pub const SlangPassThrough_SLANG_PASS_THROUGH_COUNT_OF: SlangPassThrough = 10;
pub type SlangPassThrough = SlangPassThroughIntegral;
pub type SlangArchiveTypeIntegral = ::std::os::raw::c_int;
pub const SlangArchiveType_SLANG_ARCHIVE_TYPE_UNDEFINED: SlangArchiveType = 0;
pub const SlangArchiveType_SLANG_ARCHIVE_TYPE_ZIP: SlangArchiveType = 1;
#[doc = "< Riff container with no compression"]
pub const SlangArchiveType_SLANG_ARCHIVE_TYPE_RIFF: SlangArchiveType = 2;
pub const SlangArchiveType_SLANG_ARCHIVE_TYPE_RIFF_DEFLATE: SlangArchiveType = 3;
pub const SlangArchiveType_SLANG_ARCHIVE_TYPE_RIFF_LZ4: SlangArchiveType = 4;
pub const SlangArchiveType_SLANG_ARCHIVE_TYPE_COUNT_OF: SlangArchiveType = 5;
pub type SlangArchiveType = SlangArchiveTypeIntegral;
#[doc = "Flags to control compilation behavior."]
pub type SlangCompileFlags = ::std::os::raw::c_uint;
pub const SLANG_COMPILE_FLAG_NO_MANGLING: ::std::os::raw::c_int = 8;
pub const SLANG_COMPILE_FLAG_NO_CODEGEN: ::std::os::raw::c_int = 16;
pub const SLANG_COMPILE_FLAG_OBFUSCATE: ::std::os::raw::c_int = 32;
pub const SLANG_COMPILE_FLAG_NO_CHECKING: ::std::os::raw::c_int = 0;
pub const SLANG_COMPILE_FLAG_SPLIT_MIXED_TYPES: ::std::os::raw::c_int = 0;
pub type _bindgen_ty_5 = ::std::os::raw::c_int;
#[doc = "@brief Flags to control code generation behavior of a compilation target"]
pub type SlangTargetFlags = ::std::os::raw::c_uint;
pub const SLANG_TARGET_FLAG_PARAMETER_BLOCKS_USE_REGISTER_SPACES: ::std::os::raw::c_int = 16;
pub const SLANG_TARGET_FLAG_GENERATE_WHOLE_PROGRAM: ::std::os::raw::c_int = 256;
pub const SLANG_TARGET_FLAG_DUMP_IR: ::std::os::raw::c_int = 512;
pub const SLANG_TARGET_FLAG_GENERATE_SPIRV_DIRECTLY: ::std::os::raw::c_int = 1024;
pub type _bindgen_ty_6 = ::std::os::raw::c_int;
#[doc = "@brief Options to control floating-point precision guarantees for a target."]
pub type SlangFloatingPointMode = ::std::os::raw::c_uint;
pub const SLANG_FLOATING_POINT_MODE_DEFAULT: ::std::os::raw::c_int = 0;
pub const SLANG_FLOATING_POINT_MODE_FAST: ::std::os::raw::c_int = 1;
pub const SLANG_FLOATING_POINT_MODE_PRECISE: ::std::os::raw::c_int = 2;
pub type _bindgen_ty_7 = ::std::os::raw::c_int;
#[doc = "@brief Options to control emission of `#line` directives"]
pub type SlangLineDirectiveMode = ::std::os::raw::c_uint;
#[doc = "< Default behavior: pick behavior base on target."]
pub const SLANG_LINE_DIRECTIVE_MODE_DEFAULT: ::std::os::raw::c_int = 0;
#[doc = "< Don't emit line directives at all."]
pub const SLANG_LINE_DIRECTIVE_MODE_NONE: ::std::os::raw::c_int = 1;
#[doc = "< Emit standard C-style `#line` directives."]
pub const SLANG_LINE_DIRECTIVE_MODE_STANDARD: ::std::os::raw::c_int = 2;
#[doc = "< Emit GLSL-style directives with file *number* instead of name"]
pub const SLANG_LINE_DIRECTIVE_MODE_GLSL: ::std::os::raw::c_int = 3;
pub type _bindgen_ty_8 = ::std::os::raw::c_int;
pub type SlangSourceLanguageIntegral = ::std::os::raw::c_int;
pub const SlangSourceLanguage_SLANG_SOURCE_LANGUAGE_UNKNOWN: SlangSourceLanguage = 0;
pub const SlangSourceLanguage_SLANG_SOURCE_LANGUAGE_SLANG: SlangSourceLanguage = 1;
pub const SlangSourceLanguage_SLANG_SOURCE_LANGUAGE_HLSL: SlangSourceLanguage = 2;
pub const SlangSourceLanguage_SLANG_SOURCE_LANGUAGE_GLSL: SlangSourceLanguage = 3;
pub const SlangSourceLanguage_SLANG_SOURCE_LANGUAGE_C: SlangSourceLanguage = 4;
pub const SlangSourceLanguage_SLANG_SOURCE_LANGUAGE_CPP: SlangSourceLanguage = 5;
pub const SlangSourceLanguage_SLANG_SOURCE_LANGUAGE_CUDA: SlangSourceLanguage = 6;
pub const SlangSourceLanguage_SLANG_SOURCE_LANGUAGE_COUNT_OF: SlangSourceLanguage = 7;
pub type SlangSourceLanguage = SlangSourceLanguageIntegral;
pub type SlangProfileID = ::std::os::raw::c_uint;
pub const SLANG_PROFILE_UNKNOWN: ::std::os::raw::c_int = 0;
pub type _bindgen_ty_9 = ::std::os::raw::c_int;
pub type SlangCapabilityID = SlangInt32;
pub const SLANG_CAPABILITY_UNKNOWN: ::std::os::raw::c_int = 0;
pub type _bindgen_ty_10 = ::std::os::raw::c_int;
pub type SlangMatrixLayoutMode = ::std::os::raw::c_uint;
pub const SLANG_MATRIX_LAYOUT_MODE_UNKNOWN: ::std::os::raw::c_int = 0;
pub const SLANG_MATRIX_LAYOUT_ROW_MAJOR: ::std::os::raw::c_int = 1;
pub const SLANG_MATRIX_LAYOUT_COLUMN_MAJOR: ::std::os::raw::c_int = 2;
pub type _bindgen_ty_11 = ::std::os::raw::c_int;
pub type SlangStage = SlangUInt32;
pub const SLANG_STAGE_NONE: ::std::os::raw::c_int = 0;
pub const SLANG_STAGE_VERTEX: ::std::os::raw::c_int = 1;
pub const SLANG_STAGE_HULL: ::std::os::raw::c_int = 2;
pub const SLANG_STAGE_DOMAIN: ::std::os::raw::c_int = 3;
pub const SLANG_STAGE_GEOMETRY: ::std::os::raw::c_int = 4;
pub const SLANG_STAGE_FRAGMENT: ::std::os::raw::c_int = 5;
pub const SLANG_STAGE_COMPUTE: ::std::os::raw::c_int = 6;
pub const SLANG_STAGE_RAY_GENERATION: ::std::os::raw::c_int = 7;
pub const SLANG_STAGE_INTERSECTION: ::std::os::raw::c_int = 8;
pub const SLANG_STAGE_ANY_HIT: ::std::os::raw::c_int = 9;
pub const SLANG_STAGE_CLOSEST_HIT: ::std::os::raw::c_int = 10;
pub const SLANG_STAGE_MISS: ::std::os::raw::c_int = 11;
pub const SLANG_STAGE_CALLABLE: ::std::os::raw::c_int = 12;
pub const SLANG_STAGE_MESH: ::std::os::raw::c_int = 13;
pub const SLANG_STAGE_AMPLIFICATION: ::std::os::raw::c_int = 14;
pub const SLANG_STAGE_PIXEL: ::std::os::raw::c_int = 5;
pub type _bindgen_ty_12 = ::std::os::raw::c_int;
pub type SlangDebugInfoLevel = SlangUInt32;
#[doc = "< Don't emit debug information at all."]
pub const SLANG_DEBUG_INFO_LEVEL_NONE: ::std::os::raw::c_int = 0;
#[doc = "< Emit as little debug information as possible, while still supporting stack trackes."]
pub const SLANG_DEBUG_INFO_LEVEL_MINIMAL: ::std::os::raw::c_int = 1;
#[doc = "< Emit whatever is the standard level of debug information for each target."]
pub const SLANG_DEBUG_INFO_LEVEL_STANDARD: ::std::os::raw::c_int = 2;
#[doc = "< Emit as much debug infromation as possible for each target."]
pub const SLANG_DEBUG_INFO_LEVEL_MAXIMAL: ::std::os::raw::c_int = 3;
pub type _bindgen_ty_13 = ::std::os::raw::c_int;
pub type SlangOptimizationLevel = SlangUInt32;
#[doc = "< Don't optimize at all."]
pub const SLANG_OPTIMIZATION_LEVEL_NONE: ::std::os::raw::c_int = 0;
#[doc = "< Default optimization level: balance code quality and compilation time."]
pub const SLANG_OPTIMIZATION_LEVEL_DEFAULT: ::std::os::raw::c_int = 1;
#[doc = "< Optimize aggressively."]
pub const SLANG_OPTIMIZATION_LEVEL_HIGH: ::std::os::raw::c_int = 2;
#[doc = "< Include optimizations that may take a very long time, or may involve severe space-vs-speed tradeoffs"]
pub const SLANG_OPTIMIZATION_LEVEL_MAXIMAL: ::std::os::raw::c_int = 3;
pub type _bindgen_ty_14 = ::std::os::raw::c_int;
#[doc = " A result code for a Slang API operation."]
#[doc = ""]
#[doc = "This type is generally compatible with the Windows API `HRESULT` type. In particular, negative values indicate"]
#[doc = "failure results, while zero or positive results indicate success."]
#[doc = ""]
#[doc = "In general, Slang APIs always return a zero result on success, unless documented otherwise. Strictly speaking"]
#[doc = "a negative value indicates an error, a positive (or 0) value indicates success. This can be tested for with the macros"]
#[doc = "SLANG_SUCCEEDED(x) or SLANG_FAILED(x)."]
#[doc = ""]
#[doc = "It can represent if the call was successful or not. It can also specify in an extensible manner what facility"]
#[doc = "produced the result (as the integral 'facility') as well as what caused it (as an integral 'code')."]
#[doc = "Under the covers SlangResult is represented as a int32_t."]
#[doc = ""]
#[doc = "SlangResult is designed to be compatible with COM HRESULT."]
#[doc = ""]
#[doc = "It's layout in bits is as follows"]
#[doc = ""]
#[doc = "Severity | Facility | Code"]
#[doc = "---------|----------|-----"]
#[doc = "31       |    30-16 | 15-0"]
#[doc = ""]
#[doc = "Severity - 1 fail, 0 is success - as SlangResult is signed 32 bits, means negative number indicates failure."]
#[doc = "Facility is where the error originated from. Code is the code specific to the facility."]
#[doc = ""]
#[doc = "Result codes have the following styles,"]
#[doc = "1) SLANG_name"]
#[doc = "2) SLANG_s_f_name"]
#[doc = "3) SLANG_s_name"]
#[doc = ""]
#[doc = "where s is S for success, E for error"]
#[doc = "f is the short version of the facility name"]
#[doc = ""]
#[doc = "Style 1 is reserved for SLANG_OK and SLANG_FAIL as they are so commonly used."]
#[doc = ""]
#[doc = "It is acceptable to expand 'f' to a longer name to differentiate a name or drop if unique without it."]
#[doc = "ie for a facility 'DRIVER' it might make sense to have an error of the form SLANG_E_DRIVER_OUT_OF_MEMORY"]
pub type SlangResult = i32;
#[doc = " A \"Universally Unique Identifier\" (UUID)"]
#[doc = ""]
#[doc = "The Slang API uses UUIDs to identify interfaces when"]
#[doc = "using `queryInterface`."]
#[doc = ""]
#[doc = "This type is compatible with the `GUID` type defined"]
#[doc = "by the Component Object Model (COM), but Slang is"]
#[doc = "not dependent on COM."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SlangUUID {
    pub data1: u32,
    pub data2: u16,
    pub data3: u16,
    pub data4: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_SlangUUID() {
    assert_eq!(
        ::std::mem::size_of::<SlangUUID>(),
        16usize,
        concat!("Size of: ", stringify!(SlangUUID))
    );
    assert_eq!(
        ::std::mem::align_of::<SlangUUID>(),
        4usize,
        concat!("Alignment of ", stringify!(SlangUUID))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SlangUUID>())).data1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SlangUUID),
            "::",
            stringify!(data1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SlangUUID>())).data2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SlangUUID),
            "::",
            stringify!(data2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SlangUUID>())).data3 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(SlangUUID),
            "::",
            stringify!(data3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SlangUUID>())).data4 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SlangUUID),
            "::",
            stringify!(data4)
        )
    );
}
#[repr(C)]
pub struct ISlangUnknown__bindgen_vtable(::std::os::raw::c_void);
#[doc = " Base interface for components exchanged through the API."]
#[doc = ""]
#[doc = "This interface definition is compatible with the COM `IUnknown`,"]
#[doc = "and uses the same UUID, but Slang does not require applications"]
#[doc = "to use or initialize COM."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISlangUnknown {
    pub vtable_: *const ISlangUnknown__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_ISlangUnknown() {
    assert_eq!(
        ::std::mem::size_of::<ISlangUnknown>(),
        8usize,
        concat!("Size of: ", stringify!(ISlangUnknown))
    );
    assert_eq!(
        ::std::mem::align_of::<ISlangUnknown>(),
        8usize,
        concat!("Alignment of ", stringify!(ISlangUnknown))
    );
}
#[doc = " A \"blob\" of binary data."]
#[doc = ""]
#[doc = "This interface definition is compatible with the `ID3DBlob` and `ID3D10Blob` interfaces."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISlangBlob {
    pub _base: ISlangUnknown,
}
#[test]
fn bindgen_test_layout_ISlangBlob() {
    assert_eq!(
        ::std::mem::size_of::<ISlangBlob>(),
        8usize,
        concat!("Size of: ", stringify!(ISlangBlob))
    );
    assert_eq!(
        ::std::mem::align_of::<ISlangBlob>(),
        8usize,
        concat!("Alignment of ", stringify!(ISlangBlob))
    );
}
#[doc = " A (real or virtual) file system."]
#[doc = ""]
#[doc = "Slang can make use of this interface whenever it would otherwise try to load files"]
#[doc = "from disk, allowing applications to hook and/or override filesystem access from"]
#[doc = "the compiler."]
#[doc = ""]
#[doc = "It is the responsibility of"]
#[doc = "the caller of any method that returns a ISlangBlob to release the blob when it is no"]
#[doc = "longer used (using 'release')."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISlangFileSystem {
    pub _base: ISlangUnknown,
}
#[test]
fn bindgen_test_layout_ISlangFileSystem() {
    assert_eq!(
        ::std::mem::size_of::<ISlangFileSystem>(),
        8usize,
        concat!("Size of: ", stringify!(ISlangFileSystem))
    );
    assert_eq!(
        ::std::mem::align_of::<ISlangFileSystem>(),
        8usize,
        concat!("Alignment of ", stringify!(ISlangFileSystem))
    );
}
pub type SlangFuncPtr = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = " An interface that can be used to encapsulate access to a shared library. An implementation"]
#[doc = "does not have to implement the library as a shared library."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISlangSharedLibrary {
    pub _base: ISlangUnknown,
}
#[test]
fn bindgen_test_layout_ISlangSharedLibrary() {
    assert_eq!(
        ::std::mem::size_of::<ISlangSharedLibrary>(),
        8usize,
        concat!("Size of: ", stringify!(ISlangSharedLibrary))
    );
    assert_eq!(
        ::std::mem::align_of::<ISlangSharedLibrary>(),
        8usize,
        concat!("Alignment of ", stringify!(ISlangSharedLibrary))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISlangSharedLibraryLoader {
    pub _base: ISlangUnknown,
}
#[test]
fn bindgen_test_layout_ISlangSharedLibraryLoader() {
    assert_eq!(
        ::std::mem::size_of::<ISlangSharedLibraryLoader>(),
        8usize,
        concat!("Size of: ", stringify!(ISlangSharedLibraryLoader))
    );
    assert_eq!(
        ::std::mem::align_of::<ISlangSharedLibraryLoader>(),
        8usize,
        concat!("Alignment of ", stringify!(ISlangSharedLibraryLoader))
    );
}
pub type SlangPathType = ::std::os::raw::c_uint;
#[doc = "< Path specified specifies a directory."]
pub const SLANG_PATH_TYPE_DIRECTORY: ::std::os::raw::c_int = 0;
#[doc = "< Path specified is to a file."]
pub const SLANG_PATH_TYPE_FILE: ::std::os::raw::c_int = 1;
pub type _bindgen_ty_15 = ::std::os::raw::c_int;
pub type FileSystemContentsCallBack = ::std::option::Option<
    unsafe extern "C" fn(
        pathType: SlangPathType,
        name: *const ::std::os::raw::c_char,
        userData: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " An extended file system abstraction."]
#[doc = ""]
#[doc = "Implementing and using this interface over ISlangFileSystem gives much more control over how paths"]
#[doc = "are managed, as well as how it is determined if two files 'are the same'."]
#[doc = ""]
#[doc = "All paths as input char*, or output as ISlangBlobs are always encoded as UTF-8 strings."]
#[doc = "Blobs that contain strings are always zero terminated."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISlangFileSystemExt {
    pub _base: ISlangFileSystem,
}
#[test]
fn bindgen_test_layout_ISlangFileSystemExt() {
    assert_eq!(
        ::std::mem::size_of::<ISlangFileSystemExt>(),
        8usize,
        concat!("Size of: ", stringify!(ISlangFileSystemExt))
    );
    assert_eq!(
        ::std::mem::align_of::<ISlangFileSystemExt>(),
        8usize,
        concat!("Alignment of ", stringify!(ISlangFileSystemExt))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISlangMutableFileSystem {
    pub _base: ISlangFileSystemExt,
}
#[test]
fn bindgen_test_layout_ISlangMutableFileSystem() {
    assert_eq!(
        ::std::mem::size_of::<ISlangMutableFileSystem>(),
        8usize,
        concat!("Size of: ", stringify!(ISlangMutableFileSystem))
    );
    assert_eq!(
        ::std::mem::align_of::<ISlangMutableFileSystem>(),
        8usize,
        concat!("Alignment of ", stringify!(ISlangMutableFileSystem))
    );
}
pub type SlangWriterChannel = ::std::os::raw::c_uint;
pub const SLANG_WRITER_CHANNEL_DIAGNOSTIC: ::std::os::raw::c_int = 0;
pub const SLANG_WRITER_CHANNEL_STD_OUTPUT: ::std::os::raw::c_int = 1;
pub const SLANG_WRITER_CHANNEL_STD_ERROR: ::std::os::raw::c_int = 2;
pub const SLANG_WRITER_CHANNEL_COUNT_OF: ::std::os::raw::c_int = 3;
pub type _bindgen_ty_16 = ::std::os::raw::c_int;
pub type SlangWriterMode = ::std::os::raw::c_uint;
pub const SLANG_WRITER_MODE_TEXT: ::std::os::raw::c_int = 0;
pub const SLANG_WRITER_MODE_BINARY: ::std::os::raw::c_int = 1;
pub type _bindgen_ty_17 = ::std::os::raw::c_int;
#[doc = " A stream typically of text, used for outputting diagnostic as well as other information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISlangWriter {
    pub _base: ISlangUnknown,
}
#[test]
fn bindgen_test_layout_ISlangWriter() {
    assert_eq!(
        ::std::mem::size_of::<ISlangWriter>(),
        8usize,
        concat!("Size of: ", stringify!(ISlangWriter))
    );
    assert_eq!(
        ::std::mem::align_of::<ISlangWriter>(),
        8usize,
        concat!("Alignment of ", stringify!(ISlangWriter))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slang_TypeReflection {
    pub _address: u8,
}
pub const slang_TypeReflection_Kind_None: slang_TypeReflection_Kind = 0;
pub const slang_TypeReflection_Kind_Struct: slang_TypeReflection_Kind = 1;
pub const slang_TypeReflection_Kind_Array: slang_TypeReflection_Kind = 2;
pub const slang_TypeReflection_Kind_Matrix: slang_TypeReflection_Kind = 3;
pub const slang_TypeReflection_Kind_Vector: slang_TypeReflection_Kind = 4;
pub const slang_TypeReflection_Kind_Scalar: slang_TypeReflection_Kind = 5;
pub const slang_TypeReflection_Kind_ConstantBuffer: slang_TypeReflection_Kind = 6;
pub const slang_TypeReflection_Kind_Resource: slang_TypeReflection_Kind = 7;
pub const slang_TypeReflection_Kind_SamplerState: slang_TypeReflection_Kind = 8;
pub const slang_TypeReflection_Kind_TextureBuffer: slang_TypeReflection_Kind = 9;
pub const slang_TypeReflection_Kind_ShaderStorageBuffer: slang_TypeReflection_Kind = 10;
pub const slang_TypeReflection_Kind_ParameterBlock: slang_TypeReflection_Kind = 11;
pub const slang_TypeReflection_Kind_GenericTypeParameter: slang_TypeReflection_Kind = 12;
pub const slang_TypeReflection_Kind_Interface: slang_TypeReflection_Kind = 13;
pub const slang_TypeReflection_Kind_OutputStream: slang_TypeReflection_Kind = 14;
pub const slang_TypeReflection_Kind_Specialized: slang_TypeReflection_Kind = 15;
pub const slang_TypeReflection_Kind_Feedback: slang_TypeReflection_Kind = 16;
pub type slang_TypeReflection_Kind = ::std::os::raw::c_int;
pub const slang_TypeReflection_ScalarType_None: slang_TypeReflection_ScalarType = 0;
pub const slang_TypeReflection_ScalarType_Void: slang_TypeReflection_ScalarType = 1;
pub const slang_TypeReflection_ScalarType_Bool: slang_TypeReflection_ScalarType = 2;
pub const slang_TypeReflection_ScalarType_Int32: slang_TypeReflection_ScalarType = 3;
pub const slang_TypeReflection_ScalarType_UInt32: slang_TypeReflection_ScalarType = 4;
pub const slang_TypeReflection_ScalarType_Int64: slang_TypeReflection_ScalarType = 5;
pub const slang_TypeReflection_ScalarType_UInt64: slang_TypeReflection_ScalarType = 6;
pub const slang_TypeReflection_ScalarType_Float16: slang_TypeReflection_ScalarType = 7;
pub const slang_TypeReflection_ScalarType_Float32: slang_TypeReflection_ScalarType = 8;
pub const slang_TypeReflection_ScalarType_Float64: slang_TypeReflection_ScalarType = 9;
pub const slang_TypeReflection_ScalarType_Int8: slang_TypeReflection_ScalarType = 10;
pub const slang_TypeReflection_ScalarType_UInt8: slang_TypeReflection_ScalarType = 11;
pub const slang_TypeReflection_ScalarType_Int16: slang_TypeReflection_ScalarType = 12;
pub const slang_TypeReflection_ScalarType_UInt16: slang_TypeReflection_ScalarType = 13;
pub type slang_TypeReflection_ScalarType = SlangScalarType;
#[test]
fn bindgen_test_layout_slang_TypeReflection() {
    assert_eq!(
        ::std::mem::size_of::<slang_TypeReflection>(),
        1usize,
        concat!("Size of: ", stringify!(slang_TypeReflection))
    );
    assert_eq!(
        ::std::mem::align_of::<slang_TypeReflection>(),
        1usize,
        concat!("Alignment of ", stringify!(slang_TypeReflection))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slang_TypeLayoutReflection {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_slang_TypeLayoutReflection() {
    assert_eq!(
        ::std::mem::size_of::<slang_TypeLayoutReflection>(),
        1usize,
        concat!("Size of: ", stringify!(slang_TypeLayoutReflection))
    );
    assert_eq!(
        ::std::mem::align_of::<slang_TypeLayoutReflection>(),
        1usize,
        concat!("Alignment of ", stringify!(slang_TypeLayoutReflection))
    );
}
pub const slang_LayoutRules_Default: slang_LayoutRules = 0;
pub type slang_LayoutRules = SlangLayoutRules;
pub type slang_ProgramLayout = slang_ShaderReflection;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slang_ShaderReflection {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_slang_ShaderReflection() {
    assert_eq!(
        ::std::mem::size_of::<slang_ShaderReflection>(),
        1usize,
        concat!("Size of: ", stringify!(slang_ShaderReflection))
    );
    assert_eq!(
        ::std::mem::align_of::<slang_ShaderReflection>(),
        1usize,
        concat!("Alignment of ", stringify!(slang_ShaderReflection))
    );
}
pub type slang_CompileStdLibFlags = u32;
#[doc = " A \"blob\" of binary data."]
#[doc = ""]
#[doc = "This interface definition is compatible with the `ID3DBlob` and `ID3D10Blob` interfaces."]
pub type slang_IBlob = ISlangBlob;
#[doc = " A global session for interaction with the Slang library."]
#[doc = ""]
#[doc = "An application may create and re-use a single global session across"]
#[doc = "multiple sessions, in order to amortize startups costs (in current"]
#[doc = "Slang this is mostly the cost of loading the Slang standard library)."]
#[doc = ""]
#[doc = "The global session is currently *not* thread-safe and objects created from"]
#[doc = "a single global session should only be used from a single thread at"]
#[doc = "a time."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slang_IGlobalSession {
    pub _base: ISlangUnknown,
}
#[test]
fn bindgen_test_layout_slang_IGlobalSession() {
    assert_eq!(
        ::std::mem::size_of::<slang_IGlobalSession>(),
        8usize,
        concat!("Size of: ", stringify!(slang_IGlobalSession))
    );
    assert_eq!(
        ::std::mem::align_of::<slang_IGlobalSession>(),
        8usize,
        concat!("Alignment of ", stringify!(slang_IGlobalSession))
    );
}
#[doc = "@brief A request for one or more compilation actions to be performed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slang_ICompileRequest {
    pub _base: ISlangUnknown,
}
#[test]
fn bindgen_test_layout_slang_ICompileRequest() {
    assert_eq!(
        ::std::mem::size_of::<slang_ICompileRequest>(),
        8usize,
        concat!("Size of: ", stringify!(slang_ICompileRequest))
    );
    assert_eq!(
        ::std::mem::align_of::<slang_ICompileRequest>(),
        8usize,
        concat!("Alignment of ", stringify!(slang_ICompileRequest))
    );
}
#[doc = " Description of a code generation target."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slang_TargetDesc {
    #[doc = " The size of this structure, in bytes."]
    pub structureSize: usize,
    #[doc = " The target format to generate code for (e.g., SPIR-V, DXIL, etc.)"]
    pub format: SlangCompileTarget,
    #[doc = " The compilation profile supported by the target (e.g., \"Shader Model 5.1\")"]
    pub profile: SlangProfileID,
    #[doc = " Flags for the code generation target. Currently unused."]
    pub flags: SlangTargetFlags,
    #[doc = " Default mode to use for floating-point operations on the target."]
    pub floatingPointMode: SlangFloatingPointMode,
    #[doc = " Optimization level to use for the target."]
    pub optimizationLevel: SlangOptimizationLevel,
    #[doc = " The line directive mode for output source code."]
    pub lineDirectiveMode: SlangLineDirectiveMode,
    #[doc = " Whether to force `scalar` layout for glsl shader storage buffers."]
    pub forceGLSLScalarBufferLayout: bool,
}
#[test]
fn bindgen_test_layout_slang_TargetDesc() {
    assert_eq!(
        ::std::mem::size_of::<slang_TargetDesc>(),
        40usize,
        concat!("Size of: ", stringify!(slang_TargetDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<slang_TargetDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(slang_TargetDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<slang_TargetDesc>())).structureSize as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slang_TargetDesc),
            "::",
            stringify!(structureSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<slang_TargetDesc>())).format as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slang_TargetDesc),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<slang_TargetDesc>())).profile as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(slang_TargetDesc),
            "::",
            stringify!(profile)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<slang_TargetDesc>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(slang_TargetDesc),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<slang_TargetDesc>())).floatingPointMode as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(slang_TargetDesc),
            "::",
            stringify!(floatingPointMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<slang_TargetDesc>())).optimizationLevel as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(slang_TargetDesc),
            "::",
            stringify!(optimizationLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<slang_TargetDesc>())).lineDirectiveMode as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(slang_TargetDesc),
            "::",
            stringify!(lineDirectiveMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<slang_TargetDesc>())).forceGLSLScalarBufferLayout as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(slang_TargetDesc),
            "::",
            stringify!(forceGLSLScalarBufferLayout)
        )
    );
}
pub type slang_SessionFlags = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slang_PreprocessorMacroDesc {
    pub name: *const ::std::os::raw::c_char,
    pub value: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_slang_PreprocessorMacroDesc() {
    assert_eq!(
        ::std::mem::size_of::<slang_PreprocessorMacroDesc>(),
        16usize,
        concat!("Size of: ", stringify!(slang_PreprocessorMacroDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<slang_PreprocessorMacroDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(slang_PreprocessorMacroDesc))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<slang_PreprocessorMacroDesc>())).name as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slang_PreprocessorMacroDesc),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<slang_PreprocessorMacroDesc>())).value as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slang_PreprocessorMacroDesc),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slang_SessionDesc {
    #[doc = " The size of this structure, in bytes."]
    pub structureSize: usize,
    #[doc = " Code generation targets to include in the session."]
    pub targets: *const slang_TargetDesc,
    pub targetCount: SlangInt,
    #[doc = " Flags to configure the session."]
    pub flags: slang_SessionFlags,
    #[doc = " Default layout to assume for variables with matrix types."]
    pub defaultMatrixLayoutMode: SlangMatrixLayoutMode,
    #[doc = " Paths to use when searching for `#include`d or `import`ed files."]
    pub searchPaths: *const *const ::std::os::raw::c_char,
    pub searchPathCount: SlangInt,
    pub preprocessorMacros: *const slang_PreprocessorMacroDesc,
    pub preprocessorMacroCount: SlangInt,
}
#[test]
fn bindgen_test_layout_slang_SessionDesc() {
    assert_eq!(
        ::std::mem::size_of::<slang_SessionDesc>(),
        64usize,
        concat!("Size of: ", stringify!(slang_SessionDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<slang_SessionDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(slang_SessionDesc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<slang_SessionDesc>())).structureSize as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slang_SessionDesc),
            "::",
            stringify!(structureSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<slang_SessionDesc>())).targets as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slang_SessionDesc),
            "::",
            stringify!(targets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<slang_SessionDesc>())).targetCount as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(slang_SessionDesc),
            "::",
            stringify!(targetCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<slang_SessionDesc>())).flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(slang_SessionDesc),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<slang_SessionDesc>())).defaultMatrixLayoutMode as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(slang_SessionDesc),
            "::",
            stringify!(defaultMatrixLayoutMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<slang_SessionDesc>())).searchPaths as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(slang_SessionDesc),
            "::",
            stringify!(searchPaths)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<slang_SessionDesc>())).searchPathCount as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(slang_SessionDesc),
            "::",
            stringify!(searchPathCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<slang_SessionDesc>())).preprocessorMacros as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(slang_SessionDesc),
            "::",
            stringify!(preprocessorMacros)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<slang_SessionDesc>())).preprocessorMacroCount as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(slang_SessionDesc),
            "::",
            stringify!(preprocessorMacroCount)
        )
    );
}
pub const slang_ContainerType_None: slang_ContainerType = 0;
pub const slang_ContainerType_UnsizedArray: slang_ContainerType = 1;
pub const slang_ContainerType_StructuredBuffer: slang_ContainerType = 2;
pub const slang_ContainerType_ConstantBuffer: slang_ContainerType = 3;
pub const slang_ContainerType_ParameterBlock: slang_ContainerType = 4;
pub type slang_ContainerType = ::std::os::raw::c_int;
#[doc = " A session provides a scope for code that is loaded."]
#[doc = ""]
#[doc = "A session can be used to load modules of Slang source code,"]
#[doc = "and to request target-specific compiled binaries and layout"]
#[doc = "information."]
#[doc = ""]
#[doc = "In order to be able to load code, the session owns a set"]
#[doc = "of active \"search paths\" for resolving `#include` directives"]
#[doc = "and `import` declrations, as well as a set of global"]
#[doc = "preprocessor definitions that will be used for all code"]
#[doc = "that gets `import`ed in the session."]
#[doc = ""]
#[doc = "If multiple user shaders are loaded in the same session,"]
#[doc = "and import the same module (e.g., two source files do `import X`)"]
#[doc = "then there will only be one copy of `X` loaded within the session."]
#[doc = ""]
#[doc = "In order to be able to generate target code, the session"]
#[doc = "owns a list of available compilation targets, which specify"]
#[doc = "code generation options."]
#[doc = ""]
#[doc = "Code loaded and compiled within a session is owned by the session"]
#[doc = "and will remain resident in memory until the session is released."]
#[doc = "Applications wishing to control the memory usage for compiled"]
#[doc = "and loaded code should use multiple sessions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slang_ISession {
    pub _base: ISlangUnknown,
}
#[test]
fn bindgen_test_layout_slang_ISession() {
    assert_eq!(
        ::std::mem::size_of::<slang_ISession>(),
        8usize,
        concat!("Size of: ", stringify!(slang_ISession))
    );
    assert_eq!(
        ::std::mem::align_of::<slang_ISession>(),
        8usize,
        concat!("Alignment of ", stringify!(slang_ISession))
    );
}
#[doc = " A component type is a unit of shader code layout, reflection, and linking."]
#[doc = ""]
#[doc = "A component type is a unit of shader code that can be included into"]
#[doc = "a linked and compiled shader program. Each component type may have:"]
#[doc = ""]
#[doc = " Zero or more uniform shader parameters, representing textures,"]
#[doc = "buffers, etc. that the code in the component depends on."]
#[doc = ""]
#[doc = " Zero or more *specialization* parameters, which are type or"]
#[doc = "value parameters that can be used to synthesize specialized"]
#[doc = "versions of the component type."]
#[doc = ""]
#[doc = " Zero or more entry points, which are the individually invocable"]
#[doc = "kernels that can have final code generated."]
#[doc = ""]
#[doc = " Zero or more *requirements*, which are other component"]
#[doc = "types on which the component type depends."]
#[doc = ""]
#[doc = "One example of a component type is a module of Slang code:"]
#[doc = ""]
#[doc = " The global-scope shader parameters declared in the module are"]
#[doc = "the parameters when considered as a component type."]
#[doc = ""]
#[doc = " Any global-scope generic or interface type parameters introduce"]
#[doc = "specialization parameters for the module."]
#[doc = ""]
#[doc = " A module does not by default include any entry points when"]
#[doc = "considered as a component type (although the code of the"]
#[doc = "module might *declare* some entry points)."]
#[doc = ""]
#[doc = " Any other modules that are `import`ed in the source code"]
#[doc = "become requirements of the module, when considered as a"]
#[doc = "component type."]
#[doc = ""]
#[doc = "An entry point is another example of a component type:"]
#[doc = ""]
#[doc = " The `uniform` parameters of the entry point function are"]
#[doc = "its shader parameters when considered as a component type."]
#[doc = ""]
#[doc = " Any generic or interface-type parameters of the entry point"]
#[doc = "introduce specialization parameters."]
#[doc = ""]
#[doc = " An entry point component type exposes a single entry point (itself)."]
#[doc = ""]
#[doc = " An entry point has one requirement for the module in which"]
#[doc = "it was defined."]
#[doc = ""]
#[doc = "Component types can be manipulated in a few ways:"]
#[doc = ""]
#[doc = " Multiple component types can be combined into a composite, which"]
#[doc = "combines all of their code, parameters, etc."]
#[doc = ""]
#[doc = " A component type can be specialized, by \"plugging in\" types and"]
#[doc = "values for its specialization parameters."]
#[doc = ""]
#[doc = " A component type can be laid out for a particular target, giving"]
#[doc = "offsets/bindings to the shader parameters it contains."]
#[doc = ""]
#[doc = " Generated kernel code can be requested for entry points."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slang_IComponentType {
    pub _base: ISlangUnknown,
}
#[test]
fn bindgen_test_layout_slang_IComponentType() {
    assert_eq!(
        ::std::mem::size_of::<slang_IComponentType>(),
        8usize,
        concat!("Size of: ", stringify!(slang_IComponentType))
    );
    assert_eq!(
        ::std::mem::align_of::<slang_IComponentType>(),
        8usize,
        concat!("Alignment of ", stringify!(slang_IComponentType))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slang_IEntryPoint {
    pub _base: slang_IComponentType,
}
#[test]
fn bindgen_test_layout_slang_IEntryPoint() {
    assert_eq!(
        ::std::mem::size_of::<slang_IEntryPoint>(),
        8usize,
        concat!("Size of: ", stringify!(slang_IEntryPoint))
    );
    assert_eq!(
        ::std::mem::align_of::<slang_IEntryPoint>(),
        8usize,
        concat!("Alignment of ", stringify!(slang_IEntryPoint))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slang_ITypeConformance {
    pub _base: slang_IComponentType,
}
#[test]
fn bindgen_test_layout_slang_ITypeConformance() {
    assert_eq!(
        ::std::mem::size_of::<slang_ITypeConformance>(),
        8usize,
        concat!("Size of: ", stringify!(slang_ITypeConformance))
    );
    assert_eq!(
        ::std::mem::align_of::<slang_ITypeConformance>(),
        8usize,
        concat!("Alignment of ", stringify!(slang_ITypeConformance))
    );
}
#[doc = " A module is the granularity of shader code compilation and loading."]
#[doc = ""]
#[doc = "In most cases a module corresponds to a single compile \"translation unit.\""]
#[doc = "This will often be a single `.slang` or `.hlsl` file and everything it"]
#[doc = "`#include`s."]
#[doc = ""]
#[doc = "Notably, a module `M` does *not* include the things it `import`s, as these"]
#[doc = "as distinct modules that `M` depends on. There is a directed graph of"]
#[doc = "module dependencies, and all modules in the graph must belong to the"]
#[doc = "same session (`ISession`)."]
#[doc = ""]
#[doc = "A module establishes a namespace for looking up types, functions, etc."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slang_IModule {
    pub _base: slang_IComponentType,
}
#[test]
fn bindgen_test_layout_slang_IModule() {
    assert_eq!(
        ::std::mem::size_of::<slang_IModule>(),
        8usize,
        concat!("Size of: ", stringify!(slang_IModule))
    );
    assert_eq!(
        ::std::mem::align_of::<slang_IModule>(),
        8usize,
        concat!("Alignment of ", stringify!(slang_IModule))
    );
}
#[doc = " Argument used for specialization to types/values."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct slang_SpecializationArg {
    #[doc = " The kind of specialization argument."]
    pub kind: slang_SpecializationArg_Kind,
    pub __bindgen_anon_1: slang_SpecializationArg__bindgen_ty_1,
}
#[doc = "< An invalid specialization argument."]
pub const slang_SpecializationArg_Kind_Unknown: slang_SpecializationArg_Kind = 0;
#[doc = "< Specialize to a type."]
pub const slang_SpecializationArg_Kind_Type: slang_SpecializationArg_Kind = 1;
pub type slang_SpecializationArg_Kind = i32;
#[repr(C)]
#[derive(Copy, Clone)]
pub union slang_SpecializationArg__bindgen_ty_1 {
    #[doc = " A type specialization argument, used for `Kind::Type`."]
    pub type_: *mut slang_TypeReflection,
}
#[test]
fn bindgen_test_layout_slang_SpecializationArg__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<slang_SpecializationArg__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(slang_SpecializationArg__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<slang_SpecializationArg__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(slang_SpecializationArg__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<slang_SpecializationArg__bindgen_ty_1>())).type_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slang_SpecializationArg__bindgen_ty_1),
            "::",
            stringify!(type_)
        )
    );
}
#[test]
fn bindgen_test_layout_slang_SpecializationArg() {
    assert_eq!(
        ::std::mem::size_of::<slang_SpecializationArg>(),
        16usize,
        concat!("Size of: ", stringify!(slang_SpecializationArg))
    );
    assert_eq!(
        ::std::mem::align_of::<slang_SpecializationArg>(),
        8usize,
        concat!("Alignment of ", stringify!(slang_SpecializationArg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<slang_SpecializationArg>())).kind as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slang_SpecializationArg),
            "::",
            stringify!(kind)
        )
    );
}
#[doc = " A global session for interaction with the Slang library."]
#[doc = ""]
#[doc = "An application may create and re-use a single global session across"]
#[doc = "multiple sessions, in order to amortize startups costs (in current"]
#[doc = "Slang this is mostly the cost of loading the Slang standard library)."]
#[doc = ""]
#[doc = "The global session is currently *not* thread-safe and objects created from"]
#[doc = "a single global session should only be used from a single thread at"]
#[doc = "a time."]
pub type SlangSession = slang_IGlobalSession;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SlangProgramLayout {
    _unused: [u8; 0],
}
#[doc = "@brief A request for one or more compilation actions to be performed."]
pub type SlangCompileRequest = slang_ICompileRequest;
extern "C" {
    #[doc = "@brief Initialize an instance of the Slang library."]
    pub fn spCreateSession(deprecated: *const ::std::os::raw::c_char) -> *mut SlangSession;
}
extern "C" {
    #[doc = "@brief Clean up after an instance of the Slang library."]
    pub fn spDestroySession(session: *mut SlangSession);
}
extern "C" {
    #[doc = " @see slang::IGlobalSession::setSharedLibraryLoader"]
    pub fn spSessionSetSharedLibraryLoader(
        session: *mut SlangSession,
        loader: *mut ISlangSharedLibraryLoader,
    );
}
extern "C" {
    #[doc = " @see slang::IGlobalSession::getSharedLibraryLoader"]
    pub fn spSessionGetSharedLibraryLoader(
        session: *mut SlangSession,
    ) -> *mut ISlangSharedLibraryLoader;
}
extern "C" {
    #[doc = " @see slang::IGlobalSession::checkCompileTargetSupport"]
    pub fn spSessionCheckCompileTargetSupport(
        session: *mut SlangSession,
        target: SlangCompileTarget,
    ) -> SlangResult;
}
extern "C" {
    #[doc = " @see slang::IGlobalSession::checkPassThroughSupport"]
    pub fn spSessionCheckPassThroughSupport(
        session: *mut SlangSession,
        passThrough: SlangPassThrough,
    ) -> SlangResult;
}
extern "C" {
    #[doc = " @see slang::IGlobalSession::addBuiltins"]
    pub fn spAddBuiltins(
        session: *mut SlangSession,
        sourcePath: *const ::std::os::raw::c_char,
        sourceString: *const ::std::os::raw::c_char,
    );
}
#[doc = "@brief Callback type used for diagnostic output."]
pub type SlangDiagnosticCallback = ::std::option::Option<
    unsafe extern "C" fn(
        message: *const ::std::os::raw::c_char,
        userData: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = "@brief Get the build version 'tag' string. The string is the same as produced via `git describe --tags`"]
    #[doc = "for the project. If Slang is built separately from the automated build scripts"]
    #[doc = "the contents will by default be 'unknown'. Any string can be set by changing the"]
    #[doc = "contents of 'slang-tag-version.h' file and recompiling the project."]
    #[doc = ""]
    #[doc = "This function will return exactly the same result as the method getBuildTag string on IGlobalSession."]
    #[doc = ""]
    #[doc = "An advantage of using this function over the method is that doing so does not require the creation of"]
    #[doc = "a session, which can be a fairly costly operation."]
    #[doc = ""]
    #[doc = "@return The build tag string"]
    pub fn spGetBuildTagString() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn spCreateCompileRequest(session: *mut SlangSession) -> *mut SlangCompileRequest;
}
extern "C" {
    #[doc = "@brief Destroy a compile request."]
    #[doc = "Note a request is a COM object and can be destroyed via 'Release'."]
    pub fn spDestroyCompileRequest(request: *mut SlangCompileRequest);
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::setFileSystem"]
    pub fn spSetFileSystem(request: *mut SlangCompileRequest, fileSystem: *mut ISlangFileSystem);
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::setCompileFlags"]
    pub fn spSetCompileFlags(request: *mut SlangCompileRequest, flags: SlangCompileFlags);
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::setDumpIntermediates"]
    pub fn spSetDumpIntermediates(request: *mut SlangCompileRequest, enable: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::setDumpIntermediatePrefix"]
    pub fn spSetDumpIntermediatePrefix(
        request: *mut SlangCompileRequest,
        prefix: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " DEPRECATED: use `spSetTargetLineDirectiveMode` instead."]
    #[doc = "@see slang::ICompileRequest::setLineDirectiveMode"]
    pub fn spSetLineDirectiveMode(request: *mut SlangCompileRequest, mode: SlangLineDirectiveMode);
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::setTargetLineDirectiveMode"]
    pub fn spSetTargetLineDirectiveMode(
        request: *mut SlangCompileRequest,
        targetIndex: ::std::os::raw::c_int,
        mode: SlangLineDirectiveMode,
    );
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::setTargetLineDirectiveMode"]
    pub fn spSetTargetForceGLSLScalarBufferLayout(
        request: *mut SlangCompileRequest,
        targetIndex: ::std::os::raw::c_int,
        forceScalarLayout: bool,
    );
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::setCodeGenTarget"]
    pub fn spSetCodeGenTarget(request: *mut SlangCompileRequest, target: SlangCompileTarget);
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::addCodeGenTarget"]
    pub fn spAddCodeGenTarget(
        request: *mut SlangCompileRequest,
        target: SlangCompileTarget,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::setTargetProfile"]
    pub fn spSetTargetProfile(
        request: *mut SlangCompileRequest,
        targetIndex: ::std::os::raw::c_int,
        profile: SlangProfileID,
    );
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::setTargetFlags"]
    pub fn spSetTargetFlags(
        request: *mut SlangCompileRequest,
        targetIndex: ::std::os::raw::c_int,
        flags: SlangTargetFlags,
    );
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::setTargetFloatingPointMode"]
    pub fn spSetTargetFloatingPointMode(
        request: *mut SlangCompileRequest,
        targetIndex: ::std::os::raw::c_int,
        mode: SlangFloatingPointMode,
    );
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::addTargetCapability"]
    pub fn spAddTargetCapability(
        request: *mut slang_ICompileRequest,
        targetIndex: ::std::os::raw::c_int,
        capability: SlangCapabilityID,
    );
}
extern "C" {
    pub fn spSetTargetMatrixLayoutMode(
        request: *mut SlangCompileRequest,
        targetIndex: ::std::os::raw::c_int,
        mode: SlangMatrixLayoutMode,
    );
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::setMatrixLayoutMode"]
    pub fn spSetMatrixLayoutMode(request: *mut SlangCompileRequest, mode: SlangMatrixLayoutMode);
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::setDebugInfoLevel"]
    pub fn spSetDebugInfoLevel(request: *mut SlangCompileRequest, level: SlangDebugInfoLevel);
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::setOptimizationLevel"]
    pub fn spSetOptimizationLevel(request: *mut SlangCompileRequest, level: SlangOptimizationLevel);
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::setOutputContainerFormat"]
    pub fn spSetOutputContainerFormat(
        request: *mut SlangCompileRequest,
        format: SlangContainerFormat,
    );
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::setPassThrough"]
    pub fn spSetPassThrough(request: *mut SlangCompileRequest, passThrough: SlangPassThrough);
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::setDiagnosticCallback"]
    pub fn spSetDiagnosticCallback(
        request: *mut SlangCompileRequest,
        callback: SlangDiagnosticCallback,
        userData: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::setWriter"]
    pub fn spSetWriter(
        request: *mut SlangCompileRequest,
        channel: SlangWriterChannel,
        writer: *mut ISlangWriter,
    );
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::getWriter"]
    pub fn spGetWriter(
        request: *mut SlangCompileRequest,
        channel: SlangWriterChannel,
    ) -> *mut ISlangWriter;
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::addSearchPath"]
    pub fn spAddSearchPath(
        request: *mut SlangCompileRequest,
        searchDir: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::addPreprocessorDefine"]
    pub fn spAddPreprocessorDefine(
        request: *mut SlangCompileRequest,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::processCommandLineArguments"]
    pub fn spProcessCommandLineArguments(
        request: *mut SlangCompileRequest,
        args: *const *const ::std::os::raw::c_char,
        argCount: ::std::os::raw::c_int,
    ) -> SlangResult;
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::addTranslationUnit"]
    pub fn spAddTranslationUnit(
        request: *mut SlangCompileRequest,
        language: SlangSourceLanguage,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::setDefaultModuleName"]
    pub fn spSetDefaultModuleName(
        request: *mut SlangCompileRequest,
        defaultModuleName: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::addPreprocessorDefine"]
    pub fn spTranslationUnit_addPreprocessorDefine(
        request: *mut SlangCompileRequest,
        translationUnitIndex: ::std::os::raw::c_int,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::addTranslationUnitSourceFile"]
    pub fn spAddTranslationUnitSourceFile(
        request: *mut SlangCompileRequest,
        translationUnitIndex: ::std::os::raw::c_int,
        path: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::addTranslationUnitSourceString"]
    pub fn spAddTranslationUnitSourceString(
        request: *mut SlangCompileRequest,
        translationUnitIndex: ::std::os::raw::c_int,
        path: *const ::std::os::raw::c_char,
        source: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::addLibraryReference"]
    pub fn spAddLibraryReference(
        request: *mut SlangCompileRequest,
        libData: *const ::std::os::raw::c_void,
        libDataSize: usize,
    ) -> SlangResult;
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::addTranslationUnitSourceStringSpan"]
    pub fn spAddTranslationUnitSourceStringSpan(
        request: *mut SlangCompileRequest,
        translationUnitIndex: ::std::os::raw::c_int,
        path: *const ::std::os::raw::c_char,
        sourceBegin: *const ::std::os::raw::c_char,
        sourceEnd: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::addTranslationUnitSourceBlob"]
    pub fn spAddTranslationUnitSourceBlob(
        request: *mut SlangCompileRequest,
        translationUnitIndex: ::std::os::raw::c_int,
        path: *const ::std::os::raw::c_char,
        sourceBlob: *mut ISlangBlob,
    );
}
extern "C" {
    #[doc = " @see slang::IGlobalSession::findProfile"]
    pub fn spFindProfile(
        session: *mut SlangSession,
        name: *const ::std::os::raw::c_char,
    ) -> SlangProfileID;
}
extern "C" {
    #[doc = " @see slang::IGlobalSession::findCapability"]
    pub fn spFindCapability(
        session: *mut SlangSession,
        name: *const ::std::os::raw::c_char,
    ) -> SlangCapabilityID;
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::addEntryPoint"]
    pub fn spAddEntryPoint(
        request: *mut SlangCompileRequest,
        translationUnitIndex: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        stage: SlangStage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::addEntryPointEx"]
    pub fn spAddEntryPointEx(
        request: *mut SlangCompileRequest,
        translationUnitIndex: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        stage: SlangStage,
        genericArgCount: ::std::os::raw::c_int,
        genericArgs: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::setGlobalGenericArgs"]
    pub fn spSetGlobalGenericArgs(
        request: *mut SlangCompileRequest,
        genericArgCount: ::std::os::raw::c_int,
        genericArgs: *mut *const ::std::os::raw::c_char,
    ) -> SlangResult;
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::setTypeNameForGlobalExistentialTypeParam"]
    pub fn spSetTypeNameForGlobalExistentialTypeParam(
        request: *mut SlangCompileRequest,
        slotIndex: ::std::os::raw::c_int,
        typeName: *const ::std::os::raw::c_char,
    ) -> SlangResult;
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::setTypeNameForEntryPointExistentialTypeParam"]
    pub fn spSetTypeNameForEntryPointExistentialTypeParam(
        request: *mut SlangCompileRequest,
        entryPointIndex: ::std::os::raw::c_int,
        slotIndex: ::std::os::raw::c_int,
        typeName: *const ::std::os::raw::c_char,
    ) -> SlangResult;
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::compile"]
    pub fn spCompile(request: *mut SlangCompileRequest) -> SlangResult;
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::getDiagnosticOutput"]
    pub fn spGetDiagnosticOutput(
        request: *mut SlangCompileRequest,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::getDiagnosticOutputBlob"]
    pub fn spGetDiagnosticOutputBlob(
        request: *mut SlangCompileRequest,
        outBlob: *mut *mut ISlangBlob,
    ) -> SlangResult;
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::getDependencyFileCount"]
    pub fn spGetDependencyFileCount(request: *mut SlangCompileRequest) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::getDependencyFilePath"]
    pub fn spGetDependencyFilePath(
        request: *mut SlangCompileRequest,
        index: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::getTranslationUnitCount"]
    pub fn spGetTranslationUnitCount(request: *mut SlangCompileRequest) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::getEntryPointSource"]
    pub fn spGetEntryPointSource(
        request: *mut SlangCompileRequest,
        entryPointIndex: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::getEntryPointCode"]
    pub fn spGetEntryPointCode(
        request: *mut SlangCompileRequest,
        entryPointIndex: ::std::os::raw::c_int,
        outSize: *mut usize,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::getEntryPointCodeBlob"]
    pub fn spGetEntryPointCodeBlob(
        request: *mut SlangCompileRequest,
        entryPointIndex: ::std::os::raw::c_int,
        targetIndex: ::std::os::raw::c_int,
        outBlob: *mut *mut ISlangBlob,
    ) -> SlangResult;
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::getEntryPointHostCallable"]
    pub fn spGetEntryPointHostCallable(
        request: *mut SlangCompileRequest,
        entryPointIndex: ::std::os::raw::c_int,
        targetIndex: ::std::os::raw::c_int,
        outSharedLibrary: *mut *mut ISlangSharedLibrary,
    ) -> SlangResult;
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::getTargetCodeBlob"]
    pub fn spGetTargetCodeBlob(
        request: *mut SlangCompileRequest,
        targetIndex: ::std::os::raw::c_int,
        outBlob: *mut *mut ISlangBlob,
    ) -> SlangResult;
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::getTargetHostCallable"]
    pub fn spGetTargetHostCallable(
        request: *mut SlangCompileRequest,
        targetIndex: ::std::os::raw::c_int,
        outSharedLibrary: *mut *mut ISlangSharedLibrary,
    ) -> SlangResult;
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::getCompileRequestCode"]
    pub fn spGetCompileRequestCode(
        request: *mut SlangCompileRequest,
        outSize: *mut usize,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::getContainerCode"]
    pub fn spGetContainerCode(
        request: *mut SlangCompileRequest,
        outBlob: *mut *mut ISlangBlob,
    ) -> SlangResult;
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::loadRepro"]
    pub fn spLoadRepro(
        request: *mut SlangCompileRequest,
        fileSystem: *mut ISlangFileSystem,
        data: *const ::std::os::raw::c_void,
        size: usize,
    ) -> SlangResult;
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::saveRepro"]
    pub fn spSaveRepro(
        request: *mut SlangCompileRequest,
        outBlob: *mut *mut ISlangBlob,
    ) -> SlangResult;
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::enableReproCapture"]
    pub fn spEnableReproCapture(request: *mut SlangCompileRequest) -> SlangResult;
}
extern "C" {
    #[doc = " Extract contents of a repro."]
    #[doc = ""]
    #[doc = "Writes the contained files and manifest with their 'unique' names into fileSystem. For more details read the"]
    #[doc = "docs/repro.md documentation."]
    #[doc = ""]
    #[doc = "@param session          The slang session"]
    #[doc = "@param reproData        Holds the repro data"]
    #[doc = "@param reproDataSize    The size of the repro data"]
    #[doc = "@param fileSystem       File system that the contents of the repro will be written to"]
    #[doc = "@returns                A `SlangResult` to indicate success or failure."]
    pub fn spExtractRepro(
        session: *mut SlangSession,
        reproData: *const ::std::os::raw::c_void,
        reproDataSize: usize,
        fileSystem: *mut ISlangMutableFileSystem,
    ) -> SlangResult;
}
extern "C" {
    pub fn spLoadReproAsFileSystem(
        session: *mut SlangSession,
        reproData: *const ::std::os::raw::c_void,
        reproDataSize: usize,
        replaceFileSystem: *mut ISlangFileSystem,
        outFileSystem: *mut *mut ISlangFileSystemExt,
    ) -> SlangResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SlangEntryPoint {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SlangEntryPointLayout {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SlangReflectionModifier {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SlangReflectionType {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SlangReflectionTypeLayout {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SlangReflectionVariable {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SlangReflectionVariableLayout {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SlangReflectionTypeParameter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SlangReflectionUserAttribute {
    _unused: [u8; 0],
}
pub type SlangReflection = SlangProgramLayout;
pub type SlangReflectionEntryPoint = SlangEntryPointLayout;
extern "C" {
    pub fn spGetReflection(request: *mut SlangCompileRequest) -> *mut SlangReflection;
}
pub type SlangTypeKind = ::std::os::raw::c_uint;
pub const SLANG_TYPE_KIND_NONE: ::std::os::raw::c_int = 0;
pub const SLANG_TYPE_KIND_STRUCT: ::std::os::raw::c_int = 1;
pub const SLANG_TYPE_KIND_ARRAY: ::std::os::raw::c_int = 2;
pub const SLANG_TYPE_KIND_MATRIX: ::std::os::raw::c_int = 3;
pub const SLANG_TYPE_KIND_VECTOR: ::std::os::raw::c_int = 4;
pub const SLANG_TYPE_KIND_SCALAR: ::std::os::raw::c_int = 5;
pub const SLANG_TYPE_KIND_CONSTANT_BUFFER: ::std::os::raw::c_int = 6;
pub const SLANG_TYPE_KIND_RESOURCE: ::std::os::raw::c_int = 7;
pub const SLANG_TYPE_KIND_SAMPLER_STATE: ::std::os::raw::c_int = 8;
pub const SLANG_TYPE_KIND_TEXTURE_BUFFER: ::std::os::raw::c_int = 9;
pub const SLANG_TYPE_KIND_SHADER_STORAGE_BUFFER: ::std::os::raw::c_int = 10;
pub const SLANG_TYPE_KIND_PARAMETER_BLOCK: ::std::os::raw::c_int = 11;
pub const SLANG_TYPE_KIND_GENERIC_TYPE_PARAMETER: ::std::os::raw::c_int = 12;
pub const SLANG_TYPE_KIND_INTERFACE: ::std::os::raw::c_int = 13;
pub const SLANG_TYPE_KIND_OUTPUT_STREAM: ::std::os::raw::c_int = 14;
pub const SLANG_TYPE_KIND_SPECIALIZED: ::std::os::raw::c_int = 15;
pub const SLANG_TYPE_KIND_FEEDBACK: ::std::os::raw::c_int = 16;
pub const SLANG_TYPE_KIND_COUNT: ::std::os::raw::c_int = 17;
pub type _bindgen_ty_18 = ::std::os::raw::c_int;
pub type SlangScalarType = ::std::os::raw::c_uint;
pub const SLANG_SCALAR_TYPE_NONE: ::std::os::raw::c_int = 0;
pub const SLANG_SCALAR_TYPE_VOID: ::std::os::raw::c_int = 1;
pub const SLANG_SCALAR_TYPE_BOOL: ::std::os::raw::c_int = 2;
pub const SLANG_SCALAR_TYPE_INT32: ::std::os::raw::c_int = 3;
pub const SLANG_SCALAR_TYPE_UINT32: ::std::os::raw::c_int = 4;
pub const SLANG_SCALAR_TYPE_INT64: ::std::os::raw::c_int = 5;
pub const SLANG_SCALAR_TYPE_UINT64: ::std::os::raw::c_int = 6;
pub const SLANG_SCALAR_TYPE_FLOAT16: ::std::os::raw::c_int = 7;
pub const SLANG_SCALAR_TYPE_FLOAT32: ::std::os::raw::c_int = 8;
pub const SLANG_SCALAR_TYPE_FLOAT64: ::std::os::raw::c_int = 9;
pub const SLANG_SCALAR_TYPE_INT8: ::std::os::raw::c_int = 10;
pub const SLANG_SCALAR_TYPE_UINT8: ::std::os::raw::c_int = 11;
pub const SLANG_SCALAR_TYPE_INT16: ::std::os::raw::c_int = 12;
pub const SLANG_SCALAR_TYPE_UINT16: ::std::os::raw::c_int = 13;
pub type _bindgen_ty_19 = ::std::os::raw::c_int;
pub type SlangResourceShape = ::std::os::raw::c_uint;
pub const SLANG_RESOURCE_BASE_SHAPE_MASK: ::std::os::raw::c_int = 15;
pub const SLANG_RESOURCE_NONE: ::std::os::raw::c_int = 0;
pub const SLANG_TEXTURE_1D: ::std::os::raw::c_int = 1;
pub const SLANG_TEXTURE_2D: ::std::os::raw::c_int = 2;
pub const SLANG_TEXTURE_3D: ::std::os::raw::c_int = 3;
pub const SLANG_TEXTURE_CUBE: ::std::os::raw::c_int = 4;
pub const SLANG_TEXTURE_BUFFER: ::std::os::raw::c_int = 5;
pub const SLANG_STRUCTURED_BUFFER: ::std::os::raw::c_int = 6;
pub const SLANG_BYTE_ADDRESS_BUFFER: ::std::os::raw::c_int = 7;
pub const SLANG_RESOURCE_UNKNOWN: ::std::os::raw::c_int = 8;
pub const SLANG_ACCELERATION_STRUCTURE: ::std::os::raw::c_int = 9;
pub const SLANG_RESOURCE_EXT_SHAPE_MASK: ::std::os::raw::c_int = 240;
pub const SLANG_TEXTURE_FEEDBACK_FLAG: ::std::os::raw::c_int = 16;
pub const SLANG_TEXTURE_ARRAY_FLAG: ::std::os::raw::c_int = 64;
pub const SLANG_TEXTURE_MULTISAMPLE_FLAG: ::std::os::raw::c_int = 128;
pub const SLANG_TEXTURE_1D_ARRAY: ::std::os::raw::c_int = 65;
pub const SLANG_TEXTURE_2D_ARRAY: ::std::os::raw::c_int = 66;
pub const SLANG_TEXTURE_CUBE_ARRAY: ::std::os::raw::c_int = 68;
pub const SLANG_TEXTURE_2D_MULTISAMPLE: ::std::os::raw::c_int = 130;
pub const SLANG_TEXTURE_2D_MULTISAMPLE_ARRAY: ::std::os::raw::c_int = 194;
pub type _bindgen_ty_20 = ::std::os::raw::c_int;
pub type SlangResourceAccess = ::std::os::raw::c_uint;
pub const SLANG_RESOURCE_ACCESS_NONE: ::std::os::raw::c_int = 0;
pub const SLANG_RESOURCE_ACCESS_READ: ::std::os::raw::c_int = 1;
pub const SLANG_RESOURCE_ACCESS_READ_WRITE: ::std::os::raw::c_int = 2;
pub const SLANG_RESOURCE_ACCESS_RASTER_ORDERED: ::std::os::raw::c_int = 3;
pub const SLANG_RESOURCE_ACCESS_APPEND: ::std::os::raw::c_int = 4;
pub const SLANG_RESOURCE_ACCESS_CONSUME: ::std::os::raw::c_int = 5;
pub const SLANG_RESOURCE_ACCESS_WRITE: ::std::os::raw::c_int = 6;
pub type _bindgen_ty_21 = ::std::os::raw::c_int;
pub type SlangParameterCategory = ::std::os::raw::c_uint;
pub const SLANG_PARAMETER_CATEGORY_NONE: ::std::os::raw::c_int = 0;
pub const SLANG_PARAMETER_CATEGORY_MIXED: ::std::os::raw::c_int = 1;
pub const SLANG_PARAMETER_CATEGORY_CONSTANT_BUFFER: ::std::os::raw::c_int = 2;
pub const SLANG_PARAMETER_CATEGORY_SHADER_RESOURCE: ::std::os::raw::c_int = 3;
pub const SLANG_PARAMETER_CATEGORY_UNORDERED_ACCESS: ::std::os::raw::c_int = 4;
pub const SLANG_PARAMETER_CATEGORY_VARYING_INPUT: ::std::os::raw::c_int = 5;
pub const SLANG_PARAMETER_CATEGORY_VARYING_OUTPUT: ::std::os::raw::c_int = 6;
pub const SLANG_PARAMETER_CATEGORY_SAMPLER_STATE: ::std::os::raw::c_int = 7;
pub const SLANG_PARAMETER_CATEGORY_UNIFORM: ::std::os::raw::c_int = 8;
pub const SLANG_PARAMETER_CATEGORY_DESCRIPTOR_TABLE_SLOT: ::std::os::raw::c_int = 9;
pub const SLANG_PARAMETER_CATEGORY_SPECIALIZATION_CONSTANT: ::std::os::raw::c_int = 10;
pub const SLANG_PARAMETER_CATEGORY_PUSH_CONSTANT_BUFFER: ::std::os::raw::c_int = 11;
pub const SLANG_PARAMETER_CATEGORY_REGISTER_SPACE: ::std::os::raw::c_int = 12;
pub const SLANG_PARAMETER_CATEGORY_GENERIC: ::std::os::raw::c_int = 13;
pub const SLANG_PARAMETER_CATEGORY_RAY_PAYLOAD: ::std::os::raw::c_int = 14;
pub const SLANG_PARAMETER_CATEGORY_HIT_ATTRIBUTES: ::std::os::raw::c_int = 15;
pub const SLANG_PARAMETER_CATEGORY_CALLABLE_PAYLOAD: ::std::os::raw::c_int = 16;
pub const SLANG_PARAMETER_CATEGORY_SHADER_RECORD: ::std::os::raw::c_int = 17;
pub const SLANG_PARAMETER_CATEGORY_EXISTENTIAL_TYPE_PARAM: ::std::os::raw::c_int = 18;
pub const SLANG_PARAMETER_CATEGORY_EXISTENTIAL_OBJECT_PARAM: ::std::os::raw::c_int = 19;
pub const SLANG_PARAMETER_CATEGORY_COUNT: ::std::os::raw::c_int = 20;
pub const SLANG_PARAMETER_CATEGORY_VERTEX_INPUT: ::std::os::raw::c_int = 5;
pub const SLANG_PARAMETER_CATEGORY_FRAGMENT_OUTPUT: ::std::os::raw::c_int = 6;
pub type _bindgen_ty_22 = ::std::os::raw::c_int;
#[doc = " Types of API-managed bindings that a parameter might use."]
#[doc = ""]
#[doc = "`SlangBindingType` represents the distinct types of binding ranges that might be"]
#[doc = "understood by an underlying graphics API or cross-API abstraction layer."]
#[doc = "Several of the enumeration cases here correspond to cases of `VkDescriptorType`"]
#[doc = "defined by the Vulkan API. Note however that the values of this enumeration"]
#[doc = "are not the same as those of any particular API."]
#[doc = ""]
#[doc = "The `SlangBindingType` enumeration is distinct from `SlangParameterCategory`"]
#[doc = "because `SlangParameterCategory` differentiates the types of parameters for"]
#[doc = "the purposes of layout, where the layout rules of some targets will treat"]
#[doc = "parameters of different types as occupying the same binding space for layout"]
#[doc = "(e.g., in SPIR-V both a `Texture2D` and `SamplerState` use the same space of"]
#[doc = "`binding` indices, and are not allowed to overlap), while those same types"]
#[doc = "map to different types of bindingsin the API (e.g., both textures and samplers"]
#[doc = "use different `VkDescriptorType` values)."]
#[doc = ""]
#[doc = "When you want to answer \"what register/binding did this parameter use?\" you"]
#[doc = "should use `SlangParameterCategory`."]
#[doc = ""]
#[doc = "When you wnat to answer \"what type of descriptor range should this parameter use?\""]
#[doc = "you should use `SlangBindingType`."]
pub type SlangBindingType = SlangUInt32;
pub const SLANG_BINDING_TYPE_UNKNOWN: ::std::os::raw::c_int = 0;
pub const SLANG_BINDING_TYPE_SAMPLER: ::std::os::raw::c_int = 1;
pub const SLANG_BINDING_TYPE_TEXTURE: ::std::os::raw::c_int = 2;
pub const SLANG_BINDING_TYPE_CONSTANT_BUFFER: ::std::os::raw::c_int = 3;
pub const SLANG_BINDING_TYPE_PARAMETER_BLOCK: ::std::os::raw::c_int = 4;
pub const SLANG_BINDING_TYPE_TYPED_BUFFER: ::std::os::raw::c_int = 5;
pub const SLANG_BINDING_TYPE_RAW_BUFFER: ::std::os::raw::c_int = 6;
pub const SLANG_BINDING_TYPE_COMBINED_TEXTURE_SAMPLER: ::std::os::raw::c_int = 7;
pub const SLANG_BINDING_TYPE_INPUT_RENDER_TARGET: ::std::os::raw::c_int = 8;
pub const SLANG_BINDING_TYPE_INLINE_UNIFORM_DATA: ::std::os::raw::c_int = 9;
pub const SLANG_BINDING_TYPE_RAY_TRACTING_ACCELERATION_STRUCTURE: ::std::os::raw::c_int = 10;
pub const SLANG_BINDING_TYPE_VARYING_INPUT: ::std::os::raw::c_int = 11;
pub const SLANG_BINDING_TYPE_VARYING_OUTPUT: ::std::os::raw::c_int = 12;
pub const SLANG_BINDING_TYPE_EXISTENTIAL_VALUE: ::std::os::raw::c_int = 13;
pub const SLANG_BINDING_TYPE_PUSH_CONSTANT: ::std::os::raw::c_int = 14;
pub const SLANG_BINDING_TYPE_MUTABLE_FLAG: ::std::os::raw::c_int = 256;
pub const SLANG_BINDING_TYPE_MUTABLE_TETURE: ::std::os::raw::c_int = 258;
pub const SLANG_BINDING_TYPE_MUTABLE_TYPED_BUFFER: ::std::os::raw::c_int = 261;
pub const SLANG_BINDING_TYPE_MUTABLE_RAW_BUFFER: ::std::os::raw::c_int = 262;
pub const SLANG_BINDING_TYPE_BASE_MASK: ::std::os::raw::c_int = 255;
pub const SLANG_BINDING_TYPE_EXT_MASK: ::std::os::raw::c_int = 65280;
pub type _bindgen_ty_23 = ::std::os::raw::c_int;
pub type SlangLayoutRules = SlangUInt32;
pub const SLANG_LAYOUT_RULES_DEFAULT: ::std::os::raw::c_int = 0;
pub type _bindgen_ty_24 = ::std::os::raw::c_int;
pub type SlangModifierID = SlangUInt32;
pub const SLANG_MODIFIER_SHARED: ::std::os::raw::c_int = 0;
pub type _bindgen_ty_25 = ::std::os::raw::c_int;
extern "C" {
    pub fn spReflectionUserAttribute_GetName(
        attrib: *mut SlangReflectionUserAttribute,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn spReflectionUserAttribute_GetArgumentCount(
        attrib: *mut SlangReflectionUserAttribute,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn spReflectionUserAttribute_GetArgumentType(
        attrib: *mut SlangReflectionUserAttribute,
        index: ::std::os::raw::c_uint,
    ) -> *mut SlangReflectionType;
}
extern "C" {
    pub fn spReflectionUserAttribute_GetArgumentValueInt(
        attrib: *mut SlangReflectionUserAttribute,
        index: ::std::os::raw::c_uint,
        rs: *mut ::std::os::raw::c_int,
    ) -> SlangResult;
}
extern "C" {
    pub fn spReflectionUserAttribute_GetArgumentValueFloat(
        attrib: *mut SlangReflectionUserAttribute,
        index: ::std::os::raw::c_uint,
        rs: *mut f32,
    ) -> SlangResult;
}
extern "C" {
    #[doc = " Returns the string-typed value of a user attribute argument"]
    #[doc = "The string returned is not null-terminated. The length of the string is returned via `outSize`."]
    #[doc = "If index of out of range, or if the specified argument is not a string, the function will return nullptr."]
    pub fn spReflectionUserAttribute_GetArgumentValueString(
        attrib: *mut SlangReflectionUserAttribute,
        index: ::std::os::raw::c_uint,
        outSize: *mut usize,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn spReflectionType_GetKind(type_: *mut SlangReflectionType) -> SlangTypeKind;
}
extern "C" {
    pub fn spReflectionType_GetUserAttributeCount(
        type_: *mut SlangReflectionType,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn spReflectionType_GetUserAttribute(
        type_: *mut SlangReflectionType,
        index: ::std::os::raw::c_uint,
    ) -> *mut SlangReflectionUserAttribute;
}
extern "C" {
    pub fn spReflectionType_FindUserAttributeByName(
        type_: *mut SlangReflectionType,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SlangReflectionUserAttribute;
}
extern "C" {
    pub fn spReflectionType_GetFieldCount(
        type_: *mut SlangReflectionType,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn spReflectionType_GetFieldByIndex(
        type_: *mut SlangReflectionType,
        index: ::std::os::raw::c_uint,
    ) -> *mut SlangReflectionVariable;
}
extern "C" {
    #[doc = " Returns the number of elements in the given type."]
    #[doc = ""]
    #[doc = "This operation is valid for vector and array types. For other types it returns zero."]
    #[doc = ""]
    #[doc = "When invoked on an unbounded-size array it will return `SLANG_UNBOUNDED_SIZE`,"]
    #[doc = "which is defined to be `~size_t(0)`."]
    #[doc = ""]
    #[doc = "If the size of a type cannot be statically computed, perhaps because it depends on"]
    #[doc = "a generic parameter that has not been bound to a specific value, this function returns zero."]
    pub fn spReflectionType_GetElementCount(type_: *mut SlangReflectionType) -> usize;
}
extern "C" {
    pub fn spReflectionType_GetElementType(
        type_: *mut SlangReflectionType,
    ) -> *mut SlangReflectionType;
}
extern "C" {
    pub fn spReflectionType_GetRowCount(type_: *mut SlangReflectionType) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn spReflectionType_GetColumnCount(
        type_: *mut SlangReflectionType,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn spReflectionType_GetScalarType(type_: *mut SlangReflectionType) -> SlangScalarType;
}
extern "C" {
    pub fn spReflectionType_GetResourceShape(type_: *mut SlangReflectionType)
        -> SlangResourceShape;
}
extern "C" {
    pub fn spReflectionType_GetResourceAccess(
        type_: *mut SlangReflectionType,
    ) -> SlangResourceAccess;
}
extern "C" {
    pub fn spReflectionType_GetResourceResultType(
        type_: *mut SlangReflectionType,
    ) -> *mut SlangReflectionType;
}
extern "C" {
    pub fn spReflectionType_GetName(
        type_: *mut SlangReflectionType,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn spReflectionTypeLayout_GetType(
        type_: *mut SlangReflectionTypeLayout,
    ) -> *mut SlangReflectionType;
}
extern "C" {
    pub fn spReflectionTypeLayout_getKind(type_: *mut SlangReflectionTypeLayout) -> SlangTypeKind;
}
extern "C" {
    pub fn spReflectionTypeLayout_GetSize(
        type_: *mut SlangReflectionTypeLayout,
        category: SlangParameterCategory,
    ) -> usize;
}
extern "C" {
    pub fn spReflectionTypeLayout_GetStride(
        type_: *mut SlangReflectionTypeLayout,
        category: SlangParameterCategory,
    ) -> usize;
}
extern "C" {
    pub fn spReflectionTypeLayout_getAlignment(
        type_: *mut SlangReflectionTypeLayout,
        category: SlangParameterCategory,
    ) -> i32;
}
extern "C" {
    pub fn spReflectionTypeLayout_GetFieldByIndex(
        type_: *mut SlangReflectionTypeLayout,
        index: ::std::os::raw::c_uint,
    ) -> *mut SlangReflectionVariableLayout;
}
extern "C" {
    pub fn spReflectionTypeLayout_findFieldIndexByName(
        typeLayout: *mut SlangReflectionTypeLayout,
        nameBegin: *const ::std::os::raw::c_char,
        nameEnd: *const ::std::os::raw::c_char,
    ) -> SlangInt;
}
extern "C" {
    pub fn spReflectionTypeLayout_GetElementStride(
        type_: *mut SlangReflectionTypeLayout,
        category: SlangParameterCategory,
    ) -> usize;
}
extern "C" {
    pub fn spReflectionTypeLayout_GetElementTypeLayout(
        type_: *mut SlangReflectionTypeLayout,
    ) -> *mut SlangReflectionTypeLayout;
}
extern "C" {
    pub fn spReflectionTypeLayout_GetElementVarLayout(
        type_: *mut SlangReflectionTypeLayout,
    ) -> *mut SlangReflectionVariableLayout;
}
extern "C" {
    pub fn spReflectionTypeLayout_getContainerVarLayout(
        type_: *mut SlangReflectionTypeLayout,
    ) -> *mut SlangReflectionVariableLayout;
}
extern "C" {
    pub fn spReflectionTypeLayout_GetParameterCategory(
        type_: *mut SlangReflectionTypeLayout,
    ) -> SlangParameterCategory;
}
extern "C" {
    pub fn spReflectionTypeLayout_GetCategoryCount(
        type_: *mut SlangReflectionTypeLayout,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn spReflectionTypeLayout_GetCategoryByIndex(
        type_: *mut SlangReflectionTypeLayout,
        index: ::std::os::raw::c_uint,
    ) -> SlangParameterCategory;
}
extern "C" {
    pub fn spReflectionTypeLayout_GetMatrixLayoutMode(
        type_: *mut SlangReflectionTypeLayout,
    ) -> SlangMatrixLayoutMode;
}
extern "C" {
    pub fn spReflectionTypeLayout_getGenericParamIndex(
        type_: *mut SlangReflectionTypeLayout,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn spReflectionTypeLayout_getPendingDataTypeLayout(
        type_: *mut SlangReflectionTypeLayout,
    ) -> *mut SlangReflectionTypeLayout;
}
extern "C" {
    pub fn spReflectionTypeLayout_getSpecializedTypePendingDataVarLayout(
        type_: *mut SlangReflectionTypeLayout,
    ) -> *mut SlangReflectionVariableLayout;
}
extern "C" {
    pub fn spReflectionType_getSpecializedTypeArgCount(type_: *mut SlangReflectionType)
        -> SlangInt;
}
extern "C" {
    pub fn spReflectionType_getSpecializedTypeArgType(
        type_: *mut SlangReflectionType,
        index: SlangInt,
    ) -> *mut SlangReflectionType;
}
extern "C" {
    pub fn spReflectionTypeLayout_getBindingRangeCount(
        typeLayout: *mut SlangReflectionTypeLayout,
    ) -> SlangInt;
}
extern "C" {
    pub fn spReflectionTypeLayout_getBindingRangeType(
        typeLayout: *mut SlangReflectionTypeLayout,
        index: SlangInt,
    ) -> SlangBindingType;
}
extern "C" {
    pub fn spReflectionTypeLayout_getBindingRangeBindingCount(
        typeLayout: *mut SlangReflectionTypeLayout,
        index: SlangInt,
    ) -> SlangInt;
}
extern "C" {
    pub fn spReflectionTypeLayout_getBindingRangeLeafTypeLayout(
        typeLayout: *mut SlangReflectionTypeLayout,
        index: SlangInt,
    ) -> *mut SlangReflectionTypeLayout;
}
extern "C" {
    pub fn spReflectionTypeLayout_getBindingRangeLeafVariable(
        typeLayout: *mut SlangReflectionTypeLayout,
        index: SlangInt,
    ) -> *mut SlangReflectionVariable;
}
extern "C" {
    pub fn spReflectionTypeLayout_getFieldBindingRangeOffset(
        typeLayout: *mut SlangReflectionTypeLayout,
        fieldIndex: SlangInt,
    ) -> SlangInt;
}
extern "C" {
    pub fn spReflectionTypeLayout_getBindingRangeDescriptorSetIndex(
        typeLayout: *mut SlangReflectionTypeLayout,
        index: SlangInt,
    ) -> SlangInt;
}
extern "C" {
    pub fn spReflectionTypeLayout_getBindingRangeFirstDescriptorRangeIndex(
        typeLayout: *mut SlangReflectionTypeLayout,
        index: SlangInt,
    ) -> SlangInt;
}
extern "C" {
    pub fn spReflectionTypeLayout_getBindingRangeDescriptorRangeCount(
        typeLayout: *mut SlangReflectionTypeLayout,
        index: SlangInt,
    ) -> SlangInt;
}
extern "C" {
    pub fn spReflectionTypeLayout_getDescriptorSetCount(
        typeLayout: *mut SlangReflectionTypeLayout,
    ) -> SlangInt;
}
extern "C" {
    pub fn spReflectionTypeLayout_getDescriptorSetSpaceOffset(
        typeLayout: *mut SlangReflectionTypeLayout,
        setIndex: SlangInt,
    ) -> SlangInt;
}
extern "C" {
    pub fn spReflectionTypeLayout_getDescriptorSetDescriptorRangeCount(
        typeLayout: *mut SlangReflectionTypeLayout,
        setIndex: SlangInt,
    ) -> SlangInt;
}
extern "C" {
    pub fn spReflectionTypeLayout_getDescriptorSetDescriptorRangeIndexOffset(
        typeLayout: *mut SlangReflectionTypeLayout,
        setIndex: SlangInt,
        rangeIndex: SlangInt,
    ) -> SlangInt;
}
extern "C" {
    pub fn spReflectionTypeLayout_getDescriptorSetDescriptorRangeDescriptorCount(
        typeLayout: *mut SlangReflectionTypeLayout,
        setIndex: SlangInt,
        rangeIndex: SlangInt,
    ) -> SlangInt;
}
extern "C" {
    pub fn spReflectionTypeLayout_getDescriptorSetDescriptorRangeType(
        typeLayout: *mut SlangReflectionTypeLayout,
        setIndex: SlangInt,
        rangeIndex: SlangInt,
    ) -> SlangBindingType;
}
extern "C" {
    pub fn spReflectionTypeLayout_getDescriptorSetDescriptorRangeCategory(
        typeLayout: *mut SlangReflectionTypeLayout,
        setIndex: SlangInt,
        rangeIndex: SlangInt,
    ) -> SlangParameterCategory;
}
extern "C" {
    pub fn spReflectionTypeLayout_getSubObjectRangeCount(
        typeLayout: *mut SlangReflectionTypeLayout,
    ) -> SlangInt;
}
extern "C" {
    pub fn spReflectionTypeLayout_getSubObjectRangeBindingRangeIndex(
        typeLayout: *mut SlangReflectionTypeLayout,
        subObjectRangeIndex: SlangInt,
    ) -> SlangInt;
}
extern "C" {
    pub fn spReflectionTypeLayout_getSubObjectRangeSpaceOffset(
        typeLayout: *mut SlangReflectionTypeLayout,
        subObjectRangeIndex: SlangInt,
    ) -> SlangInt;
}
extern "C" {
    pub fn spReflectionTypeLayout_getSubObjectRangeOffset(
        typeLayout: *mut SlangReflectionTypeLayout,
        subObjectRangeIndex: SlangInt,
    ) -> *mut SlangReflectionVariableLayout;
}
extern "C" {
    pub fn spReflectionVariable_GetName(
        var: *mut SlangReflectionVariable,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn spReflectionVariable_GetType(
        var: *mut SlangReflectionVariable,
    ) -> *mut SlangReflectionType;
}
extern "C" {
    pub fn spReflectionVariable_FindModifier(
        var: *mut SlangReflectionVariable,
        modifierID: SlangModifierID,
    ) -> *mut SlangReflectionModifier;
}
extern "C" {
    pub fn spReflectionVariable_GetUserAttributeCount(
        var: *mut SlangReflectionVariable,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn spReflectionVariable_GetUserAttribute(
        var: *mut SlangReflectionVariable,
        index: ::std::os::raw::c_uint,
    ) -> *mut SlangReflectionUserAttribute;
}
extern "C" {
    pub fn spReflectionVariable_FindUserAttributeByName(
        var: *mut SlangReflectionVariable,
        session: *mut SlangSession,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SlangReflectionUserAttribute;
}
extern "C" {
    pub fn spReflectionVariableLayout_GetVariable(
        var: *mut SlangReflectionVariableLayout,
    ) -> *mut SlangReflectionVariable;
}
extern "C" {
    pub fn spReflectionVariableLayout_GetTypeLayout(
        var: *mut SlangReflectionVariableLayout,
    ) -> *mut SlangReflectionTypeLayout;
}
extern "C" {
    pub fn spReflectionVariableLayout_GetOffset(
        var: *mut SlangReflectionVariableLayout,
        category: SlangParameterCategory,
    ) -> usize;
}
extern "C" {
    pub fn spReflectionVariableLayout_GetSpace(
        var: *mut SlangReflectionVariableLayout,
        category: SlangParameterCategory,
    ) -> usize;
}
extern "C" {
    pub fn spReflectionVariableLayout_GetSemanticName(
        var: *mut SlangReflectionVariableLayout,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn spReflectionVariableLayout_GetSemanticIndex(
        var: *mut SlangReflectionVariableLayout,
    ) -> usize;
}
extern "C" {
    #[doc = " Get the stage that a variable belongs to (if any)."]
    #[doc = ""]
    #[doc = "A variable \"belongs\" to a specific stage when it is a varying input/output"]
    #[doc = "parameter either defined as part of the parameter list for an entry"]
    #[doc = "point *or* at the global scope of a stage-specific GLSL code file (e.g.,"]
    #[doc = "an `in` parameter in a GLSL `.vs` file belongs to the vertex stage)."]
    pub fn spReflectionVariableLayout_getStage(
        var: *mut SlangReflectionVariableLayout,
    ) -> SlangStage;
}
extern "C" {
    pub fn spReflectionVariableLayout_getPendingDataLayout(
        var: *mut SlangReflectionVariableLayout,
    ) -> *mut SlangReflectionVariableLayout;
}
pub type SlangReflectionParameter = SlangReflectionVariableLayout;
extern "C" {
    pub fn spReflectionParameter_GetBindingIndex(
        parameter: *mut SlangReflectionParameter,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn spReflectionParameter_GetBindingSpace(
        parameter: *mut SlangReflectionParameter,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn spReflectionEntryPoint_getName(
        entryPoint: *mut SlangReflectionEntryPoint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn spReflectionEntryPoint_getNameOverride(
        entryPoint: *mut SlangReflectionEntryPoint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn spReflectionEntryPoint_getParameterCount(
        entryPoint: *mut SlangReflectionEntryPoint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn spReflectionEntryPoint_getParameterByIndex(
        entryPoint: *mut SlangReflectionEntryPoint,
        index: ::std::os::raw::c_uint,
    ) -> *mut SlangReflectionVariableLayout;
}
extern "C" {
    pub fn spReflectionEntryPoint_getStage(
        entryPoint: *mut SlangReflectionEntryPoint,
    ) -> SlangStage;
}
extern "C" {
    pub fn spReflectionEntryPoint_getComputeThreadGroupSize(
        entryPoint: *mut SlangReflectionEntryPoint,
        axisCount: SlangUInt,
        outSizeAlongAxis: *mut SlangUInt,
    );
}
extern "C" {
    pub fn spReflectionEntryPoint_usesAnySampleRateInput(
        entryPoint: *mut SlangReflectionEntryPoint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn spReflectionEntryPoint_getVarLayout(
        entryPoint: *mut SlangReflectionEntryPoint,
    ) -> *mut SlangReflectionVariableLayout;
}
extern "C" {
    pub fn spReflectionEntryPoint_getResultVarLayout(
        entryPoint: *mut SlangReflectionEntryPoint,
    ) -> *mut SlangReflectionVariableLayout;
}
extern "C" {
    pub fn spReflectionEntryPoint_hasDefaultConstantBuffer(
        entryPoint: *mut SlangReflectionEntryPoint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn spReflectionTypeParameter_GetName(
        typeParam: *mut SlangReflectionTypeParameter,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn spReflectionTypeParameter_GetIndex(
        typeParam: *mut SlangReflectionTypeParameter,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn spReflectionTypeParameter_GetConstraintCount(
        typeParam: *mut SlangReflectionTypeParameter,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn spReflectionTypeParameter_GetConstraintByIndex(
        typeParam: *mut SlangReflectionTypeParameter,
        index: ::std::os::raw::c_uint,
    ) -> *mut SlangReflectionType;
}
extern "C" {
    pub fn spReflection_GetParameterCount(
        reflection: *mut SlangReflection,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn spReflection_GetParameterByIndex(
        reflection: *mut SlangReflection,
        index: ::std::os::raw::c_uint,
    ) -> *mut SlangReflectionParameter;
}
extern "C" {
    pub fn spReflection_GetTypeParameterCount(
        reflection: *mut SlangReflection,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn spReflection_GetTypeParameterByIndex(
        reflection: *mut SlangReflection,
        index: ::std::os::raw::c_uint,
    ) -> *mut SlangReflectionTypeParameter;
}
extern "C" {
    pub fn spReflection_FindTypeParameter(
        reflection: *mut SlangReflection,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SlangReflectionTypeParameter;
}
extern "C" {
    pub fn spReflection_FindTypeByName(
        reflection: *mut SlangReflection,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SlangReflectionType;
}
extern "C" {
    pub fn spReflection_GetTypeLayout(
        reflection: *mut SlangReflection,
        reflectionType: *mut SlangReflectionType,
        rules: SlangLayoutRules,
    ) -> *mut SlangReflectionTypeLayout;
}
extern "C" {
    pub fn spReflection_getEntryPointCount(reflection: *mut SlangReflection) -> SlangUInt;
}
extern "C" {
    pub fn spReflection_getEntryPointByIndex(
        reflection: *mut SlangReflection,
        index: SlangUInt,
    ) -> *mut SlangReflectionEntryPoint;
}
extern "C" {
    pub fn spReflection_findEntryPointByName(
        reflection: *mut SlangReflection,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SlangReflectionEntryPoint;
}
extern "C" {
    pub fn spReflection_getGlobalConstantBufferBinding(
        reflection: *mut SlangReflection,
    ) -> SlangUInt;
}
extern "C" {
    pub fn spReflection_getGlobalConstantBufferSize(reflection: *mut SlangReflection) -> usize;
}
extern "C" {
    pub fn spReflection_specializeType(
        reflection: *mut SlangReflection,
        type_: *mut SlangReflectionType,
        specializationArgCount: SlangInt,
        specializationArgs: *const *mut SlangReflectionType,
        outDiagnostics: *mut *mut ISlangBlob,
    ) -> *mut SlangReflectionType;
}
extern "C" {
    #[doc = " Get the number of hashed strings"]
    pub fn spReflection_getHashedStringCount(reflection: *mut SlangReflection) -> SlangUInt;
}
extern "C" {
    #[doc = " Get a hashed string. The number of chars is written in outCount."]
    #[doc = " The count does *NOT* including terminating 0. The returned string will be 0 terminated."]
    pub fn spReflection_getHashedString(
        reflection: *mut SlangReflection,
        index: SlangUInt,
        outCount: *mut usize,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Compute a string hash."]
    #[doc = " Count should *NOT* include terminating zero."]
    pub fn spComputeStringHash(
        chars: *const ::std::os::raw::c_char,
        count: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a type layout representing reflection information for the global-scope prameters."]
    pub fn spReflection_getGlobalParamsTypeLayout(
        reflection: *mut SlangReflection,
    ) -> *mut SlangReflectionTypeLayout;
}
extern "C" {
    #[doc = " Get a variable layout representing reflection information for the global-scope prameters."]
    pub fn spReflection_getGlobalParamsVarLayout(
        reflection: *mut SlangReflection,
    ) -> *mut SlangReflectionVariableLayout;
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::getProgram"]
    pub fn spCompileRequest_getProgram(
        request: *mut SlangCompileRequest,
        outProgram: *mut *mut slang_IComponentType,
    ) -> SlangResult;
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::getProgramWithEntryPoints"]
    pub fn spCompileRequest_getProgramWithEntryPoints(
        request: *mut SlangCompileRequest,
        outProgram: *mut *mut slang_IComponentType,
    ) -> SlangResult;
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::getEntryPoint"]
    pub fn spCompileRequest_getEntryPoint(
        request: *mut SlangCompileRequest,
        entryPointIndex: SlangInt,
        outEntryPoint: *mut *mut slang_IComponentType,
    ) -> SlangResult;
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::getModule"]
    pub fn spCompileRequest_getModule(
        request: *mut SlangCompileRequest,
        translationUnitIndex: SlangInt,
        outModule: *mut *mut slang_IModule,
    ) -> SlangResult;
}
extern "C" {
    #[doc = " @see slang::ICompileRequest::getSession"]
    pub fn spCompileRequest_getSession(
        request: *mut SlangCompileRequest,
        outSession: *mut *mut slang_ISession,
    ) -> SlangResult;
}
extern "C" {
    pub fn spGetTranslationUnitSource(
        request: *mut SlangCompileRequest,
        translationUnitIndex: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUID {
    _unused: [u8; 0],
}
